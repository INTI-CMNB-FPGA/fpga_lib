<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FPGA LIBrary: Inferring RAM from HDL Code</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FPGA LIBrary
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Inferring RAM from HDL Code </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>To infer RAM functions, synthesis tools detect sets of registers and logic that can be replaced with IP cores for device families that have dedicated RAM blocks, or may map them directly to device memory atoms. Synthesis tools typically consider all signals and variables that have a multi-dimensional array type and then create a RAM block, if applicable. This is based on the way the signals or variables are assigned or referenced in the HDL source description. Standard synthesis tools recognize single-port and simple dual-port (one read port and one write port) RAM blocks. Some tools also recognize true dual-port (two read ports and two write ports) RAM blocks that map to the memory blocks in certain devices. Some tools also infer memory blocks for array variables and signals that are referenced (read/written) by two indices, to recognize mixed-width and byte-enabled RAMs for certain coding styles. &ndash; Quartus Prime Standard Edition Handbook</p>
<h1>Types of memories</h1>
<ul>
<li>Single-Port RAM</li>
<li>Simple Dual-Port RAM (single clock and dual clock)</li>
<li>True Dual-Port RAM (single clock and dual clock)</li>
<li>Single-Port ROM</li>
<li>Dual-Port ROM</li>
</ul>
<h1>Distributed vs Block</h1>
<h2>Xilinx</h2>
<p>RAM resources are of two types:</p><ul>
<li>Distributed RAMs, implemented on properly configured slice logic</li>
<li>Dedicated block RAM resources For both types of resources, data is synchronously written into the RAM. The key difference between distributed and block RAMs lies in the way data is read from the RAM:</li>
<li>Asynchronously in the case of distributed RAM</li>
<li>Synchronously in the case of block RAM</li>
</ul>
<h2>Altera</h2>
<p>Because memory blocks in the newest devices from Altera are synchronous, RAM designs that are targeted towards architectures that contain these dedicated memory blocks must be synchronous to be mapped directly into the device architecture. For these devices, asynchronous memory logic is implemented in regular logic cells. Synchronous memory offers several advantages over asynchronous memory, including higher frequencies and thus higher memory bandwidth, increased reliability, and less standby power.</p>
<h1>Reset</h1>
<h2>Xilinx</h2>
<p>Reset is supported and optional.</p>
<h2>Altera</h2>
<p>The RAM contents of Altera memory blocks cannot be cleared with a reset signal during device operation. If your HDL code describes a RAM with a reset signal for the RAM contents, the logic is implemented in regular logic cells instead of a memory block. Altera recommends against putting RAM read or write operations in an always block or process block with a reset signal.</p>
<h1>Enable</h1>
<h2>Xilinx</h2>
<p>Optional</p>
<h2>Altera</h2>
<p>In addition to reset signals, other control logic can prevent memory logic from being inferred as a memory block. For example, you cannot use a clock enable on the read address registers in some devices because this affects the output latch of the RAM, and therefore the synthesized result in the device RAM architecture would not match the HDL description. You can use the address stall feature as a read address clock enable to avoid this limitation.</p>
<h1>Read-During-Write Behavior</h1>
<h2>Xilinx</h2>
<ul>
<li>The default mode is WRITE_FIRST.</li>
<li>WRITE_FIRST outputs the newly written data onto the output bus.</li>
<li>READ_FIRST outputs the previously stored data while new data is being written.</li>
<li>NO_CHANGE maintains the output previously generated by a read operation. This mode is the most power efficient.</li>
</ul>
<h3>Read First:</h3>
<p>process (clk) begin if (rising_edge(clk)) then if we = '1' then RAM(conv_integer(addr)) &lt;= di; end if; do &lt;= RAM(conv_integer(addr)); end if; end process;</p>
<h3>Write First (Template 1)</h3>
<p>process (clk) begin if (rising_edge(clk)) then if we = '1' then RAM(conv_integer(addr)) &lt;= di; do &lt;= di; else do &lt;= RAM(conv_integer(addr)); end if; end if; end process;</p>
<h3>Write First (Template 2)</h3>
<p>Note: xst user guide previous to S6/V6</p>
<p>process (clk) begin if clk'event and clk = '1' then if we = '1' then ram(conv_integer(addr)) &lt;= di; end if; read_addr &lt;= addr; end if; end process;</p>
<p>do &lt;= ram(conv_integer(read_addr));</p>
<h3>No Change</h3>
<p>process (clk) begin if (rising_edge(clk)) then if we = '1' then RAM(conv_integer(addr)) &lt;= di; else do &lt;= RAM(conv_integer(addr)); end if; end if; end process;</p>
<h2>Altera</h2>
<p>Synthesis tools map an HDL design into the target device architecture, with the goal of maintaining the functionality described in your source code. Therefore, if your source code specifies unsupported read-during-write behavior for the device RAM blocks, the software must implement the logic outside the RAM hardware in regular logic cells.</p>
<ul>
<li>Read new data: Quartus Prime integrated synthesis supports this mode by creating bypass logic around the synchronous memory block.</li>
<li>Read old data: Synchronous memory blocks support this behavior.</li>
<li>Read don’t care: This behavior is supported on different ports in simple dual-port mode by synchronous memory blocks.</li>
</ul>
<p>To read new data in a write operation, synthesis software adds bypass logic around the RAM block. This bypass logic increases the area utilization of the design and decreases the performance if the RAM block is part of the design’s critical path. Single-port versions do not require any logic cells to create bypass logic.</p>
<p>Altera recommends that you use the Old Data Read-During-Write coding style for most RAM blocks as long as your design does not require the RAM location’s new value when you perform a simultaneous read and write to that RAM location.</p>
<p>It is possible to create a single-clock RAM using an assign statement to read the address of mem to create the output q. By itself, the code describes new data read-during-write behavior. However, if the RAM output feeds a register in another hierarchy, a read-during-write results in the old data. Synthesis tools may not infer a RAM block if the tool cannot determine which behavior is described, such as when the memory feeds a hard hierarchical partition boundary. You should avoid using these coding styles:</p>
<p>//Verilog HDL concurrent signal assignment assign q = ram[raddr_reg]; &ndash; VHDL concurrent signal assignment q &lt;= ram(raddr_reg);</p>
<h1>Optional Output Registers</h1>
<h2>Xilinx</h2>
<p>The optional output registers improve design performance by eliminating routing delay to the CLB flip-flops for pipelined operation. An independent clock and clock enable input is provided for these output registers. As a result the output data registers hold the value independent of the input register operation.</p>
<p>All output ports are latched or registered (optional). The state of the output port does not change until the port executes another read or write operation. The default block RAM output is latch mode. The output datapath has an optional internal pipeline register. Using the register mode is strongly recommended. This allows a higher clock rate; however, it adds a clock cycle latency of one.</p>
<h2>Altera</h2>
<p>Nothing is said.</p>
<h1>Bibliography</h1>
<ul>
<li>Vivado Design Suite Synthesis - User Guide (UG901)</li>
<li>7 Series FPGAs Memory Resources - User Guide (UG473)</li>
<li>Virtex-6 FPGA Memory Resources - User Guide (UG363)</li>
<li>Spartan-6 FPGA Block RAM Resources - User Guide (UG383)</li>
<li>XST User Guide for Virtex-6 and Spartan-6 Devices (UG687)</li>
<li>Quartus Prime Standard Edition Handbook Volume 1: Design and Synthesis (QPS5V1) </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
