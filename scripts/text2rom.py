#!/usr/bin/python
#
# Text to ROM
#
# Author: Rodrigo A. Melo
#
# Copyright (c) 2018-2019 Author and INTI
# Distributed under the BSD 3-Clause License
#

import argparse, re, sys
from math import *

## Parsing the command line ###################################################

version = 'Text to ROM v1.1'

parser = argparse.ArgumentParser(
   description='Generates an HDL ROM based on input text (BIN or HEX).'
)

parser.add_argument(
   '-v', '--version',
   action='version',
   version=version
)

parser.add_argument(
   '-w', '--width',
   metavar='BITS',
   type=int,
   default=8,
   help='BITS per ROW [8].'
)

parser.add_argument(
   '-n', '--name',
   metavar='NAME',
   default='SinglePortROM',
   help='ENTITY/MODULE NAME of the ROM [SinglePortROM].'
)

parser.add_argument(
   '-l', '--language',
   metavar='HDL',
   default='vhdl',
   choices=['vhdl','verilog'],
   help='HDL language to use [vhdl].'
)

options = parser.parse_args()

width    = options.width
name     = options.name
language = options.language

## Compute ####################################################################

dwidth = width

file = ""
for line in sys.stdin:
    file += re.sub('[^0123456789ABCDEF]', '', line, 0, re.I)

length = len(file)

if not length:
   print("ERROR: input is empty.")
   exit()

is_hex = re.search('[23456789ABCDEF]', file, re.I)

if is_hex:
   if int(width%4) is not 0:
      print("ERROR: is an HEX input so the WIDTH must be a multiple of 4")
      exit()
   width = int(width/4)

if int(length%width) is not 0:
   print("ERROR: quantity of data (%i) must be a multiple of WIDTH (%i)" % (length, width))
   exit()

rows = []
for i in range (0,int(length/width)):
    rows.append(file[i*width:i*width+width])

depth  = len(rows)
awidth = int(ceil(log(depth,2)))

## Gen HDL code ###############################################################

if language.lower() == 'vhdl':
   print("--")
   print("-- ROM code generated by %s from FPGA Lib" % (version))
   print("--")
   print("-- ENTITY NAME   = %s" % (name))
   print("-- DATA WIDTH    = %s" % (dwidth))
   print("-- ADDRESS WIDTH = %s" % (awidth))
   print("-- MEMORY DEPTH  = %s" % (depth))
   print("--")
   print("")
   print("library IEEE;")
   print("use IEEE.std_logic_1164.all;")
   print("use IEEE.numeric_std.all;")
   print("")
   print("entity %s is" % (name))
   print("   port (")
   print("      clk_i  : in  std_logic;")
   print("      addr_i : in  std_logic_vector(%s downto 0);" % (awidth-1))
   print("      data_o : out std_logic_vector(%s downto 0)" % (dwidth-1))
   print("   );")
   print("end entity %s;" % (name))
   print("")
   print("architecture RTL of %s is" % (name))
   print("   type rom_type is array(0 to %s) of std_logic_vector (%s downto 0);" % (depth-1, dwidth-1))
   print("   signal rom  : rom_type := (")
   for i in range (0,len(rows)):
      eol = ',' if i < (depth-1) else ''
      if is_hex:
         print("      x\"%s\"%s" % (rows[i], eol))
      else:
         print("      \"%s\"%s" % (rows[i], eol))
   print("   );")
   print("begin")
   print("   rom_p:")
   print("   process (clk_i)")
   print("   begin")
   print("      if rising_edge(clk_i) then")
   print("         data_o <= rom(to_integer(unsigned(addr_i)));")
   print("      end if;")
   print("   end process rom_p;")
   print("end architecture RTL;")

if language.lower() == 'verilog':
   print("//")
   print("// ROM code generated by %s from FPGA Lib" % (version))
   print("//")
   print("// MODULE NAME   = %s" % (name))
   print("// DATA WIDTH    = %s" % (dwidth))
   print("// ADDRESS WIDTH = %s" % (awidth))
   print("// MEMORY DEPTH  = %s" % (depth))
   print("//")
   print("")
   print("module %s (" % (name))
   print("   input             clk_i,")
   print("   input      [%2s:0] addr_i," % (awidth-1))
   print("   output reg [%2s:0] data_o" % (dwidth-1))
   print(");")
   print("")
   #  reg [3:0] rom [0:31];
   print("   reg [%s:0] rom [0:%s];" % (dwidth-1, depth-1))
   print("")
   print("   initial begin")
   for i in range (0,len(rows)):
       base = 'h' if is_hex else 'b'
       print("      rom[%s] = %s'%s%s;" % (i, dwidth, base, rows[i]))
   print("   end")
   print("")
   print("   always @(posedge clk_i)")
   print("      data_o <= rom[addr_i];")
   print("")
   print("endmodule")
