#!/usr/bin/python
#
# Text to ROM
#
# Author: Rodrigo A. Melo
#
# Copyright (c) 2018 Author and INTI
# Distributed under the BSD 3-Clause License
#

import argparse, re, sys
from math import *

## Parsing the command line ###################################################

version = 'Text to ROM v1.0'

parser = argparse.ArgumentParser(
   description='Generates a VHDL ROM based on input text (BIN or HEX).'
)

parser.add_argument(
   '-v', '--version',
   action='version',
   version=version
)

parser.add_argument(
   '-w', '--width',
   metavar='BITS',
   type=int,
   default=8,
   help='BITS per ROW [8].'
)

parser.add_argument(
   '-n', '--name',
   metavar='NAME',
   default='SinglePortROM',
   help='ENTITY/MODULE NAME of the ROM [SinglePortROM].'
)

options = parser.parse_args()

width = options.width
name  = options.name

## Compute ####################################################################

dwidth = width

file = ""
for line in sys.stdin:
    file += re.sub('[^0123456789ABCDEF]', '', line, 0, re.I)

length = len(file)

if not length:
   print("ERROR: input is empty.")
   exit()

is_hex = re.search('[23456789ABCDEF]', file, re.I)

if is_hex:
   if int(width%4) is not 0:
      print("ERROR: is an HEX input so the WIDTH must be a multiple of 4")
      exit()
   width = int(width/4)

if int(length%width) is not 0:
   print("ERROR: quantity of data (%i) must be a multiple of WIDTH (%i)" % (length, width))
   exit()

rows = []
for i in range (0,int(length/width)):
    rows.append(file[i*width:i*width+width])

depth  = len(rows)
awidth = int(ceil(log(depth,2)))

## Gen HDL code ###############################################################

print("--")
print("-- ROM code generated by %s from FPGA Lib" % (version))
print("--")
print("-- ENTITY NAME   = %s" % (name))
print("-- DATA WIDTH    = %s" % (dwidth))
print("-- ADDRESS WIDTH = %s" % (awidth))
print("-- MEMORY DEPTH  = %s" % (depth))
print("--")
print("")
print("library IEEE;")
print("use IEEE.std_logic_1164.all;")
print("use IEEE.numeric_std.all;")
print("")
print("entity %s is" % (name))
print("   port (")
print("      clk_i  : in  std_logic;")
print("      addr_i : in  std_logic_vector(%s downto 0);" % (awidth-1))
print("      data_o : out std_logic_vector(%s downto 0)" % (dwidth-1))
print("   );")
print("end entity %s;" % (name))
print("")
print("architecture RTL of %s is" % (name))
print("   type rom_type is array(0 to %s) of std_logic_vector (%s downto 0);" % (depth-1, dwidth-1))
print("   signal rom  : rom_type := (")
for i in range (0,len(rows)):
   eol = ',' if i < (depth-1) else ''
   if is_hex:
      print("      x\"%s\"%s" % (rows[i], eol))
   else:
      print("      \"%s\"%s" % (rows[i], eol))
print("   );")
print("begin")
print("   rom_p:")
print("   process (clk_i)")
print("   begin")
print("      if rising_edge(clk_i) then")
print("         data_o <= rom(to_integer(unsigned(addr_i)));")
print("      end if;")
print("   end process rom_p;")
print("end architecture RTL;")
