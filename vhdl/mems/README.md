# Inferring RAM from HDL Code

To infer RAM functions, synthesis tools detect sets of registers and logic that can be replaced
with IP cores for device families that have dedicated RAM blocks, or may map them directly to
device memory atoms.
Synthesis tools typically consider all signals and variables that have a multi-dimensional array
type and then create a RAM block, if applicable. This is based on the way the signals or variables
are assigned or referenced in the HDL source description.
Standard synthesis tools recognize single-port and simple dual-port (one read port and one write
port) RAM blocks. Some tools also recognize true dual-port (two read ports and two write ports) RAM
blocks that map to the memory blocks in certain devices.
Some tools also infer memory blocks for array variables and signals that are referenced
(read/written) by two indices, to recognize mixed-width and byte-enabled RAMs for certain coding
styles. -- Quartus Prime Standard Edition Handbook

# Types of memories

* Single-Port RAM
* Simple Dual-Port RAM (single clock and dual clock)
* True Dual-Port RAM (single clock and dual clock)
* Single-Port ROM
* Dual-Port ROM

# Distributed vs Block

## Xilinx

RAM resources are of two types:
* Distributed RAMs, implemented on properly configured slice logic
* Dedicated block RAM resources
For both types of resources, data is synchronously written into the RAM. The key difference between
distributed and block RAMs lies in the way data is read from the RAM:
* Asynchronously in the case of distributed RAM
* Synchronously in the case of block RAM

## Altera

Because memory blocks in the newest devices from Altera are synchronous, RAM designs that are
targeted towards architectures that contain these dedicated memory blocks must be synchronous to be
mapped directly into the device architecture. For these devices, asynchronous memory logic is
implemented in regular logic cells.
Synchronous memory offers several advantages over asynchronous memory, including higher frequencies
and thus higher memory bandwidth, increased reliability, and less standby power.

# Reset

## Xilinx

Reset is supported and optional.

## Altera

The RAM contents of Altera memory blocks cannot be cleared with a reset signal during device
operation. If your HDL code describes a RAM with a reset signal for the RAM contents, the logic is
implemented in regular logic cells instead of a memory block. Altera recommends against putting RAM
read or write operations in an always block or process block with a reset signal.

# Enable

## Xilinx

Optional

## Altera

In addition to reset signals, other control logic can prevent memory logic from being inferred as a
memory block. For example, you cannot use a clock enable on the read address registers in some
devices because this affects the output latch of the RAM, and therefore the synthesized result in
the device RAM architecture would not match the HDL description. You can use the address stall
feature as a read address clock enable to avoid this limitation.

# Read-During-Write Behavior

## Xilinx

* The default mode is WRITE_FIRST.
* WRITE_FIRST outputs the newly written data onto the output bus.
* READ_FIRST outputs the previously stored data while new data is being written.
* NO_CHANGE maintains the output previously generated by a read operation.
  This mode is the most power efficient.

### Read First:

process (clk)
begin
   if (rising_edge(clk)) then
      if we = '1' then
         RAM(conv_integer(addr)) <= di;
      end if;
      do <= RAM(conv_integer(addr));
   end if;
end process;

### Write First (Template 1)

process (clk)
begin
   if (rising_edge(clk)) then
      if we = '1' then
         RAM(conv_integer(addr)) <= di;
         do <= di;
      else
         do <= RAM(conv_integer(addr));
      end if;
   end if;
end process;

### Write First (Template 2)
Note: xst user guide previous to S6/V6

process (clk)
begin
   if clk'event and clk = '1' then
      if we = '1' then
         ram(conv_integer(addr)) <= di;
      end if;
      read_addr <= addr;
   end if;
end process;

do <= ram(conv_integer(read_addr));

### No Change

process (clk)
begin
   if (rising_edge(clk)) then
      if we = '1' then
         RAM(conv_integer(addr)) <= di;
      else
         do <= RAM(conv_integer(addr));
      end if;
   end if;
end process;

## Altera

Synthesis tools map an HDL design into the target device architecture, with the goal of maintaining
the functionality described in your source code. Therefore, if your source code specifies
unsupported read-during-write behavior for the device RAM blocks, the software must implement the
logic outside the RAM hardware in regular logic cells.

* Read new data: Quartus Prime integrated synthesis supports this mode by creating bypass logic
around the synchronous memory block.
* Read old data: Synchronous memory blocks support this behavior.
* Read don’t care: This behavior is supported on different ports in simple dual-port mode by
synchronous memory blocks.

To read new data in a write operation, synthesis software adds bypass logic around the RAM block.
This bypass logic increases the area utilization of the design and decreases the performance if the
RAM block is part of the design’s critical path. Single-port versions do not require any logic
cells to create bypass logic.

Altera recommends that you use the Old Data Read-During-Write coding style for most RAM blocks as
long as your design does not require the RAM location’s new value when you perform a simultaneous
read and write to that RAM location.

It is possible to create a single-clock RAM using an assign statement to read the address of mem
to create the output q. By itself, the code describes new data read-during-write behavior. However,
if the RAM output feeds a register in another hierarchy, a read-during-write results in the old
data. Synthesis tools may not infer a RAM block if the tool cannot determine which behavior is
described, such as when the memory feeds a hard hierarchical partition boundary. You should avoid
using these coding styles:

//Verilog HDL concurrent signal assignment
assign q = ram[raddr_reg];
-- VHDL concurrent signal assignment
q <= ram(raddr_reg);

# Optional Output Registers

## Xilinx

The optional output registers improve design performance by eliminating routing delay to the CLB
flip-flops for pipelined operation. An independent clock and clock enable input is provided for
these output registers. As a result the output data registers hold the value independent of the
input register operation.

All output ports are latched or registered (optional). The state of the output port does not change
until the port executes another read or write operation. The default block RAM output is latch mode.
The output datapath has an optional internal pipeline register. Using the register mode is strongly
recommended. This allows a higher clock rate; however, it adds a clock cycle latency of one.

## Altera

Nothing is said.

# Bibliography

* Vivado Design Suite Synthesis - User Guide (UG901)
* 7 Series FPGAs Memory Resources - User Guide (UG473)
* Virtex-6 FPGA Memory Resources - User Guide (UG363)
* Spartan-6 FPGA Block RAM Resources - User Guide (UG383)
* XST User Guide for Virtex-6 and Spartan-6 Devices (UG687)
* Quartus Prime Standard Edition Handbook Volume 1: Design and Synthesis (QPS5V1)
